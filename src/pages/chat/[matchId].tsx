import { atom, useAtom } from "jotai";
import type { NextPage } from "next";
import Head from "next/head";
import { useRouter } from "next/router";
import { useEffect, useRef, useState } from "react";
import { trpc } from "../../utils/trpc";
import { userIdAtom } from "../index";
import {
  IAgoraRTCClient,
  IAgoraRTCRemoteUser,
  ICameraVideoTrack,
  IMicrophoneAudioTrack,
  IRemoteVideoTrack,
} from "agora-rtc-sdk-ng";
import Countdown from "react-countdown";

const APP_ID = process.env.NEXT_PUBLIC_AGORA_APP_ID!;
export const matchIdAtom = atom("");

const Chat: NextPage = () => {
  // const [time] = useState(Date.now() + 1000 * 10);
  const promiseRef = useRef<any>(Promise.resolve({} as any));
  const router = useRouter();
  const [userId] = useAtom(userIdAtom);

  const { matchId } = router.query;
  const [sinkUser, setsinkUser] = useState<IAgoraRTCRemoteUser>();
  const [videoTrack, setVideoTrack] = useState<ICameraVideoTrack>();
  const [, setMatchId] = useAtom(matchIdAtom);

  const matchQuery = trpc.useQuery([
    "matches.getMatch",
    { matchId: matchId as string },
  ]);

  const isSinkUser = matchQuery.data?.sinkUserId === userId;
  let otherUser = isSinkUser
    ? matchQuery.data?.sourceUser.name
    : matchQuery.data?.sinkUser.name;

  const tokenQuery = trpc.useQuery(
    ["matches.getToken", { matchId: matchId as string, userId }],
    {
      refetchOnWindowFocus: false,
    }
  );

  useEffect(() => {
    if (!matchId) return;
    setMatchId(matchId as string);
  }, [matchId, setMatchId]);

  useEffect(() => {
    if (!userId) {
      router.push("/");
      return;
    }

    const token = tokenQuery.data;
    if (!token) return;

    const connect = async () => {
      const { default: AgoraRTC } = await import("agora-rtc-sdk-ng");
      const client: IAgoraRTCClient = AgoraRTC.createClient({
        mode: "rtc",
        codec: "vp8",
      });

      await client.join(APP_ID, matchId as string, token, userId);

      client.on("user-published", (sinkUser, mediaType) => {
        client.subscribe(sinkUser, mediaType).then(() => {
          console.log("subscribe success", sinkUser);
          if (mediaType === "video") setsinkUser(sinkUser);
          // if (mediaType === "audio") {
          //   const audioTrack = sinkUser.audioTrack;
          //   audioTrack?.play();
          // }
        });
      });

      const tracks = await AgoraRTC.createMicrophoneAndCameraTracks();
      setVideoTrack(tracks[1]);
      await client.publish(tracks);
      return {
        client,
        tracks,
      };
    };
    promiseRef.current = promiseRef.current.then(connect);

    return () => {
      // client.leave();
      const disconnect = async () => {
        const { client, tracks } = await promiseRef.current;
        client.removeAllListeners();
        tracks.forEach((track: any) => {
          track.stop();
          track.close();
        });
        await client.unpublish(tracks);
        await client.leave();
      };
      promiseRef.current = promiseRef.current.then(disconnect);
    };
  }, [tokenQuery.data]);

  const handleOnTimeOut = () => {
    router.push("/done");
  };

  const changeStatusMutation = trpc.useMutation("users.changeStatus");

  useEffect(() => {
    if (!userId) return;
    changeStatusMutation.mutate({
      userId,
      status: "onGoing",
    });
  }, []);

  return (
    <>
      <Head>
        <title>Chatting</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className="container mx-auto flex flex-col items-center justify-center min-h-screen p-4">
        <h3>video</h3>
        <h4>Chatting with {otherUser} have fun</h4>
        {matchQuery.data?.endsON && (
          <Countdown
            date={parseInt(matchQuery.data?.endsON)}
            onComplete={handleOnTimeOut}
          />
        )}

        <div className="grid grid-cols-2">
          {/* self */}
          {videoTrack && (
            <div className="flex flex-col items-center">
              <VideoPlayer
                videoTrack={videoTrack}
                style={{
                  width: "300px",
                  height: "300px",
                }}
              />
              <p>self</p>
            </div>
          )}

          {/* other user */}
          {sinkUser?.videoTrack && (
            <div className="flex flex-col items-center">
              <VideoPlayer
                videoTrack={sinkUser.videoTrack}
                style={{
                  width: "500px",
                  height: "500px",
                }}
              />
              <p>other</p>
            </div>
          )}
        </div>
      </main>
    </>
  );
};

const VideoPlayer = ({
  videoTrack,
  style,
}: {
  videoTrack: IRemoteVideoTrack | ICameraVideoTrack;
  style: object;
}) => {
  const ref = useRef(null);

  useEffect(() => {
    const playerRef = ref.current;
    if (!videoTrack) return;
    if (!playerRef) return;

    videoTrack.play(playerRef);

    return () => {
      videoTrack.stop();
    };
  }, [videoTrack]);

  return <div ref={ref} style={style}></div>;
};

export default Chat;
